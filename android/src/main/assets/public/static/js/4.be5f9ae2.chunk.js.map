{"version":3,"file":"static/js/4.be5f9ae2.chunk.js","mappings":"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","sources":["../node_modules/parse-svg-path/index.js","../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts","../node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","../node_modules/pixi.js/src/rendering/renderers/types.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","../node_modules/pixi.js/src/maths/shapes/Circle.ts","../node_modules/pixi.js/src/maths/shapes/Ellipse.ts","../node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","../node_modules/pixi.js/src/maths/shapes/Polygon.ts","../node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","../node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","../node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts","../node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts","../node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","../node_modules/pixi.js/src/scene/graphics/shared/const.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","../node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","../node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/TextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/utils/data/ViewableBuffer.ts"],"sourcesContent":["\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPlugin}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    const renderGroup = target.renderGroup || target.parentRenderGroup;\n\n    bounds.applyMatrix(renderGroup.worldTransform);\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        const renderGroup = target.renderGroup || target.parentRenderGroup;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            const rootResolution = renderer.renderTarget.renderTarget.resolution;\n\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","export enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { RenderableGCSystem } from '../../../rendering/renderers/shared/texture/RenderableGCSystem';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderableGC: RenderableGCSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n\n        this.renderer.renderableGC.addManagedHash(this, '_graphicsBatchesHash');\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch._batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        graphics.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', this._destroyRenderableBound);\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n/**\n * A batchable graphics object.\n * @ignore\n */\n\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /** unique id for this graphics context */\n    public readonly uid: number = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\n\nlet maxTextures = 0;\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    if (!maxTextures)maxTextures = getMaxTexturesPerBatch();\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @memberof rendering\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @memberof rendering\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @memberof rendering\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n        let topology: Topology = 'triangle-list';\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (textureMatrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                if (matrix)\n                {\n                    textureMatrix.append(matrix.clone().invert());\n                }\n\n                buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n            }\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: Batcher = new DefaultBatcher();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuContextHash');\n        renderer.renderableGC.addManagedHash(this, '_graphicsDataContextHash');\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    /** unique id for this fill gradient */\n    public readonly uid: number = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    private _styleKey: string | null = null;\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n        this._styleKey = null;\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey)\n        {\n            return this._styleKey;\n        }\n\n        const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join('-');\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join('-');\n\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    /** unique id for this fill pattern */\n    public readonly uid: number = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    private _styleKey: string | null = null;\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey) return this._styleKey;\n\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join('-')}`;\n\n        return this._styleKey;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.clone().invert() || new Matrix();\n\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh.texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof scene\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    public adaptor: ParticleContainerAdaptor;\n    public readonly state = State.for2d();\n    public readonly renderer: Renderer;\n\n    private _gpuBufferHash: Record<number, ParticleBuffer> = Object.create(null);\n    // eslint-disable-next-line max-len\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as unknown as (renderable: Container) => void;\n\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        renderable.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBufferHash[renderable.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public destroyRenderable(renderable: ParticleContainer)\n    {\n        const buffer = this._gpuBufferHash[renderable.uid];\n\n        buffer.destroy();\n\n        this._gpuBufferHash[renderable.uid] = null;\n\n        renderable.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableMesh = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableMesh.geometry as PoolItem);\n        BigPool.return(batchableMesh as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = BigPool.get(BatchableMesh);\n\n        batchableMesh.geometry = BigPool.get(NineSliceGeometry);\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../container/Container';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_tilingSpriteDataHash');\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n\n        tilingSprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', this._destroyRenderableBound);\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'graphics';\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyle object for advanced fills.\n     * @param {FillInput} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            let key = style.styleKey;\n\n            // remove the font size..\n            key = key.substring(0, key.lastIndexOf('-'));\n\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        bitmapText.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HTMLTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HTMLTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillInput;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: StrokeInput;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        let fontSize: number;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style.fontSize == null)\n        {\n            style.fontSize = TextStyle.defaultTextStyle.fontSize;\n        }\n        else if (typeof style.fontSize === 'string')\n        {\n            // eg '34px' to number\n            fontSize = parseInt(style.fontSize as string, 10);\n        }\n        else\n        {\n            fontSize = style.fontSize as number;\n        }\n\n        const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n\n        const fills: number[] = oldStyle.fillGradientStops\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = index / (fills.length - 1);\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as Text;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        text.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.transform = text.groupTransform;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { HTMLTextStyle } from '../../text-html/HTMLTextStyle';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys: Partial<keyof TextStyle | keyof HTMLTextStyle>[] = [\n    'align',\n    'breakWords',\n    'cssOverrides',\n    'fontVariant',\n    'fontWeight',\n    'leading',\n    'letterSpacing',\n    'lineHeight',\n    'padding',\n    'textBaseline',\n    'trim',\n    'whiteSpace',\n    'wordWrap',\n    'wordWrapWidth',\n    'fontFamily',\n    'fontStyle',\n    'fontSize',\n] as const;\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = `_${valuesToIterateForKeys[i]}`;\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n    index = addDropShadowKey(style.dropShadow, key as string[], index);\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n\nfunction addDropShadowKey(dropShadow: TextStyle['dropShadow'], key: (number | string)[], index: number)\n{\n    if (!dropShadow) return index;\n\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n\n    return index;\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n"],"names":["module","exports","path","data","replace","segment","_","command","args","type","toLowerCase","numbers","match","number","map","Number","parseValues","length","push","concat","splice","unshift","Error","a","c","h","l","m","q","s","t","v","z","ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","renderGroup","parentRenderGroup","applyMatrix","worldTransform","localDisplayStatus","measurable","manageEffects","effects","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_this$_activeFilterDa","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","matrix","renderable","globalDisplayStatus","getGlobalRenderableBounds","filterArea","filterFrameTransform","cacheToLocalTransform","colorTextureSource","renderTarget","colorTexture","source","resolution","Infinity","padding","antialias","blendRequired","enabled","clipToViewport","_renderer$backBuffer$","_renderer$backBuffer","Math","min","_resolution","compatibleRenderers","backBuffer","useBackBuffer","warn","viewPort","rootViewPort","rootResolution","fitBounds","scale","ceil","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","fragTemplate","join","generateIfTestSrc","maxIfs","src","maxTexturesPerBatchCache","getMaxTexturesPerBatch","_gl$getExtension","gl","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","createShader","FRAGMENT_SHADER","fragmentSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","checkMaxIfStatementsInShader","getExtension","loseContext","addBits","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","findHooksRx","compileHooks","programSrc","_programSrc$match$map","_programSrc$match","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","arguments","undefined","results","fragment","header","mainInput","finalString","inValue","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","cacheMap","create","bitCacheMap","Map","CACHE_UID","compileHighShader","_ref","bits","cacheId","generateCacheId","vertex","vertexFragments","shaderBit","fragmentFragments","compiledVertex","index","mainStruct","indexOf","mainStart","mainEnd","extractVariableName","compiledCode","compileOutputs","compiledFragment","compileInputsAndOutputs","compileBits","highFragment","has","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","GpuProgram","from","entryPoint","compileHighShaderGlProgram","_ref2","GlProgram","_objectSpread","compileHighShaderGl","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBit","roundPixelsBitGl","maxFragmentPrecision","getMaxFragmentPrecision","getShaderPrecisionFormat","shaderFragment","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","shaderName","insertVersion","programCache","_GlProgram","defaultOptions","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","keys","processKey","processOptions","transformFeedbackVaryings","_key","createIdFromString","_attributeData","_uniformData","_uniformBlockData","key","batchSamplersUniformGroupHash","getBatchSamplersUniformGroup","batchSamplersUniformGroup","sampleValues","Int32Array","uTextures","size","isStatic","context","_context","isContextLost","canvas","DOMAdapter","createCanvas","getContext","resources","_dirty","resource","_updateKey","keyParts","_resourceId","_resource$on","currentResource","_resource$off","off","call","onResourceChange","on","getResource","_touch","tick","_touched","_resource$off2","destroyed","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractStructAndGroups","wgsl","_wgsl$match","_wgsl$match$map$filte","_wgsl$match2","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","item","group","parseInt","binding","isUniform","structs","struct","members","reduce","acc","member","name2","split","trim","some","ShaderStage","ShaderStage2","_this$layout$","_this$layout$2","_layoutKey","_attributeLocationsKey","layout","gpuLayout","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","removeStructAndGroupDuplicates","generateLayoutHash","visibility","VERTEX","FRAGMENT","sampler","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","_this$_attributeData","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","_WGSL_TO_VERTEX_TYPES","location","getAttributeInfoFromFormat","instance","extractAttributesFromGpuProgram","Buffer","EventEmitter","_size","_data","usage","label","shrinkToFit","uid","_resourceType","_updateID","_dataInt32","Array","byteLength","mappedAtCreation","descriptor","setDataWithSize","dataInt32","static","BufferUsage","STATIC","syncGPU","_updateSize","BYTES_PER_ELEMENT","emit","oldData","sizeInBytes","removeAllListeners","BufferUsage2","ensureIsBuffer","INDEX","COPY_DST","_options$instanceCoun","instanceCount","_bounds","_boundsDirty","buffers","addAttribute","addIndex","onBufferUpdate","getAttribute","id","getIndex","getBuffer","getSize","attribute","attributeOption","isArray","ensureIsAttribute","attributeId","byteSize","getGeometryBounds","destroyBuffers","attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","_attributeFormatData$","Shader","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","groupMap","WEBGPU","nameHash","j","uniformName","groupData","bindTick","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","destroyPrograms","_this$gpuProgram","_this$glProgram","bindGroup","gpu","rest","_objectWithoutProperties","_excluded","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","_uniformData$size","_uniformData$value","uniformData","ubo","_signature","blendModeIds","normal","multiply","screen","overlay","erase","max","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","default2d","State","BLEND_TO_NPM","getAdjustedBlendModeBlend","textureSource","alphaMode","CanvasPool","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","getOptimalCanvasAndContext","minWidth","minHeight","nextPow2","canvasAndContext","returnCanvasAndContext","clearRect","idCounts","idHash","groupId","RendererType2","color32BitToUniform","abgr","alpha","GraphicsPipe","adaptor","_graphicsBatchesHash","_destroyRenderableBound","destroyRenderable","_adaptor","renderableGC","addManagedHash","validateRenderable","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","didViewUpdate","_rebuild","_addToBatcher","updateRenderable","batches","_batcher","updateElement","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","groupBlendMode","uTransformMatrix","uRound","_roundPixels","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","batchClone","BigPool","BatchableGraphics","graphicsUid","GraphicsContextSystem","identityMatrix","packAsQuad","batcherName","applyTransform","_batch","uvs","geometryData","positions","vertices","indices","color","rgb","baseColor","bgr","multiplyHexColors","groupColor","groupAlpha","transform","_this$renderable","gpuBuffer","indexOffset","indexSize","attributeOffset","attributeSize","reset","Circle","radius","clone","contains","r2","dx","dy","strokeContains","alignment","outerWidth","distance","sqrt","getBounds","Rectangle","copyFrom","circle","Ellipse","halfWidth","halfHeight","normx","normy","strokeWidth","strokeOuterWidth","strokeInnerWidth","innerHorizontal","innerVertical","outerHorizontal","outerVertical","normalizedX","normalizedY","ellipse","squaredDistanceToLineSegment","x1","y1","x2","y2","d","lenSq","xx","yy","param","Polygon","_len","points","flat","p","il","closePath","slice","polygon","inside","xi","yi","xj","yj","strokeWidthSquared","rightWidthSquared","leftWidthSquared","iterationLength","sign","n","pointsDesc","currentPoint","lastX","lastY","isCornerWithinStroke","pX","pY","cornerX","cornerY","strokeWidthInner","strokeWidthOuter","RoundedRectangle","rectangle","radius2","innerX","innerY","rightBound","bottomBound","FLT_EPSILON","buildAdaptiveBezier","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","distanceTolerance","bezierSmoothness","recursive","begin","x3","y3","x4","y4","level","PI","x12","y12","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d2","abs","d3","buildAdaptiveQuadratic","buildArc","clockwise","steps","dist","pow","f","nx","cos","ny","sin","TAU","centerX","centerY","ang1","ang2","mapToEllipse","rx","ry","cosPhi","sinPhi","out2","xp","yp","approxUnitArc","a1","tan","vectorAngle","ux","uy","vx","vy","dot","acos","buildArcToSvg","px","py","cx","cy","xAxisRotation","largeArcFlag","sweepFlag","pxp","pyp","lambda","getArcCenter","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","vx2","vy2","ratio","segments","outCurvePoint","curve","tempRectangle","ShapePath","graphicsPath2D","shapePrimitives","_currentPoly","_graphicsPath2D","moveTo","startPoly","lineTo","_ensurePoly","fromX","fromY","arc","startAngle","endAngle","counterclockwise","arcTo","b1","a2","b2","mm","dd","cc","tt","k1","k2","j1","j2","qx","qy","atan2","buildArcTo","arcToSvg","bezierCurveTo","currentPoly","quadraticCurveTo","smoothing","endPoly","addPath","isIdentity","instructions","finish","rect","w","drawShape","poly","close","regularPoly","sides","rotation","delta","angle","roundPoly","corner","sideLength","internalAngle","x0","y0","roundShape","useQuadratic","g","p1","p2","pointLerp","numPoints","_thisPoint$radius","thisPoint","pRadius","lastPoint","nextPoint","lastEdgeLength","nextEdgeLength","roundedShapeQuadraticCurve","vecFrom","pp","len","sharpCorner","_p2$radius","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","cRadius","lenOut","cX","cY","roundedShapeArc","filletRect","fillet","maxFillet","inset","right","bottom","dir","chamferRect","chamfer","radiusX","radiusY","roundRect","shape","lastShape","lx","ly","tempX","tx","ty","buildPath","shapePrimitive","boundsRect","GraphicsPath","_instructions$slice","svgPath","commands","parse","subpaths","currentSubPath","bezierCurveToShort","quadraticCurveToShort","startX","startY","SVGToGraphicsPath","shapePath","_shapePath","_len2","_key2","_len3","_key3","_len4","_key4","last","getLastPoint","currentX","currentY","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","cpx1","cpy1","_len9","_key9","_len10","_key10","_len11","_key11","_len12","_key12","_len13","_key13","_len14","_key14","_len15","_key15","star","innerRadius","r","deep","newGraphicsPath2D","cpx2","cpy2","adjustTransform","lastInstruction","currentMatrix","SVGParser","svg","div","document","createElement","innerHTML","querySelector","renderChildren","session","fillStyle","strokeStyle","f1","s1","useFill","useStroke","styleParts","stylePart","Color","setValue","toNumber","stroke","parseFloatAttribute","fill","parseStyle","pointsString","graphicsPath","nodeName","beginPath","console","info","defaultValue","tmpPoint","_GraphicsContext","dirty","batchMode","_activePath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","defaultStrokeStyle","_stateStack","_tick","toFillStyle","toStrokeStyle","setFillStyle","setStrokeStyle","tint","dw","dh","image","onUpdate","deprecation","v8_0_0","_initNextPathLocation","cut","holePath","hole","_this$_activePath","transformedX","transformedY","cpx","cpy","restore","save","getTransform","resetTransform","identity","rotate","setTransform","append","outerPadding","containsPoint","point","hasHit","k","shapes","transformedPoint","applyInverse","holes","_holes$shapePath","holeShapes","destroyTextureSource","WHITE","miterLimit","cap","pixelLine","GraphicsContext","cachedGroups","getTextureBatchBindGroup","textures","imul","bindGroupResources","generateTextureBatchBindGroup","fastCopy","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","Float64Array","remainingBytes","sourceUint8View","Uint8Array","BatchTextureArray","ids","count","Batch","gpuBindGroup","batcher","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","BATCH_TICK","_Batcher","_Batcher$defaultOptio","batchIndex","_elements","attributesInitialSize","indicesInitialSize","attributeBuffer","ViewableBuffer","Uint16Array","elementSize","elementStart","_batchIndexStart","_batchIndexSize","batchableObject","_indexStart","_attributeStart","vertexSize","checkAndUpdateTexture","textureId","_textureId","packQuadAttributes","float32View","uint32View","packAttributes","elements","textureBatch","firstElement","_resizeAttributeBuffer","_resizeIndexBuffer","element","adjustedBlendMode","breakRequired","_batchTick","_finishBatch","_textureBindLocation","packQuadIndex","packIndex","indexStart","ensureAttributeBuffer","ensureIndexBuffer","newSize","newArrayBuffer","rawBinaryData","newIndexBuffer","indicesOffset","Batcher","placeHolderBufferData","placeHolderIndexData","BatchGeometry","aUV","aColor","aTextureIdAndRound","DefaultShader","batchSamplers","defaultShader","_DefaultBatcher","textureIdAndRound","wt","argb","i2","w0","w1","h0","h1","DefaultBatcher","transformVertices","buildCircle","ShapeBuilder","build","roundedRect","j3","j4","y22","x02","y02","x22","triangulate","verticesStride","verticesOffset","centerIndex","buildEllipse","buildRoundedRectangle","closePointEps","square","innerWeight","outerWeight","verts","exx","eyy","eix","eiy","eox","eoy","round","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","angleDiff","absAngleDiff","segCount","angleInc","triangulateWithHoles","triangles","earcut","emptyArray","buildPolygon","buildRectangle","rectData","verticesIndex","buildTriangle","shapeBuilders","handleByMap","tempRect","addTextureToGeometryData","vertOffset","textureUvs","graphicsBatch","addShapePathToGeometryData","isStroke","_shape$closePath","lineStyle","closed","eps","fx","fy","buildPixelLine","flipAlignment","orientation","area","getOrientationOfPoints","firstPoint","closedShape","closedPath","midPointX","midPointY","indexCount","widthSquared","miterLimitSquared","perpX","perpY","perp1x","perp1y","dx0","dy0","dx1","dy1","cross","c1","c2","pDist","imx","imy","omx","omy","insideWeight","curveEps","buildLine","holeIndices","otherPoints","holeArrays","holePrimitives","holePrimitive","holePoints","getHoleArrays","uvsOffset","textureMatrix","uvsStride","buildUvs","buildSimpleUvs","GpuGraphicsContext","GraphicsContextRenderData","InstructionSet","v8_3_4","_GraphicsContextSystem","_gpuContextHash","_graphicsDataContextHash","_options$bezierSmooth","getContextRenderData","_initContextRenderData","_initContext","_cleanGraphicsContextData","buildContextBatches","graphicsData","drawBatches","onGraphicsContextDestroy","CanvasSystem","_FillGradient","gradientStops","_styleKey","addColorStop","toHexa","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillRect","ImageSource","addressModeU","addressModeV","styleKey","stops","toArray","FillGradient","repetitionMap","repeat","FillPattern","repetition","isFillPattern","isFillGradient","handleFillPattern","defaultStyle","handleFillGradient","objectStyle","isColorLike","temp","handleColorLike","_style$matrix","sourceStyle","addressMode","handleFillObject","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","batchableMesh","_getBatchableMesh","gpuBatchableMesh","_texture","gpuMesh","_initMeshData","_mesh$_geometry$indic","_mesh$_geometry$posit","_initBatchableMesh","BatchableMesh","_uvUpdateId","_textureMatrixUpdateId","_topology","uvBuffer","transformedUvs","isSimple","_transformedUvs","multiplyUvs","_MeshGeometry","shrinkBuffersToFit","MeshGeometry","GlParticleContainerAdaptor","particleContainerPipe","uTexture","getBuffers","glType","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","generateUpdateFunction","properties","dynamic","funcFragments","property","code","functionSource","Function","ParticleBuffer","_options$size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","_dynamicBuffer","attributeName","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","ParticleShader","uSampler","TextureStyle","uTranslationMatrix","uResolution","ParticleContainerPipe","_gpuBufferHash","_renderable","_initBuffer","_properties","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","_PlaneGeometry","super","verticesX","verticesY","_this$verticesX","_this$verticesY","_this$width","_this$height","total","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","PlaneGeometry","_NineSliceGeometry","_options$width","_options$height","_options$originalWidt","_options$originalHeig","_options$leftWidth","_options$rightWidth","_options$topHeight","_options$bottomHeight","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updateUvs","updatePositions","scaleW","scaleH","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","localUniformBit","localUniformBitGl","tilingBit","tilingBitGl","TilingSpriteShader","_gpuProgram","_glProgram","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","mapCoord","QuadGeometry","sharedQuad","TilingSpritePipe","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","_tileTransform","_tilingSpriteData$sha","_initTilingSpriteData","renderableData","applyAnchorToTexture","array","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","BatchableSprite","Graphics","ViewContainer","_ownedContext","onViewUpdate","allowChildren","updateBounds","_callContextMethod","method","_len16","_key16","_len17","_key17","_len18","_key18","_len19","_key19","_len20","_key20","_len21","_key21","_len22","_key22","_len23","_key23","_len24","_key24","_len25","_key25","_len26","_key26","rotateTransform","_len27","_key27","scaleTransform","_len28","_key28","_len29","_key29","_len30","_key30","translateTransform","_len31","_key31","beginFill","endFill","drawCircle","_len32","_key32","drawEllipse","_len33","_key33","drawPolygon","_len34","_key34","drawRect","_len35","_key35","drawRoundedRect","_len36","_key36","drawStar","_len37","_key37","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","AbstractBitmapFont","chars","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","range","pages","applyFillAsTint","baseMeasurementFontSize","baseRenderedFontSize","font","pageTextures","distanceFieldRange","distanceFieldType","destroyTextures","_this$chars$i$texture","page","resolveCharacters","result","startCode","charCodeAt","endCode","String","fromCharCode","_DynamicBitmapFont","_dynamicOptions$skipK","_dynamicOptions$resol","_dynamicOptions$paddi","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","_textureSize","textureSize","_mipmap","mipmap","overrideFill","_fill","requestedFontSize","fontStringFromTextStyle","overrideSize","_stroke","_style","skipKerning","CanvasTextMetrics","measureFont","ensureCharacters","charList","char","includes","self","pageData","_nextPage","fontScale","maxCharHeight","skipTexture","maxTextureWidth","maxTextureHeight","_style$dropShadow$dis","_style$dropShadow","_style$_stroke$width","_style$_stroke","metrics","measureText","paddedWidth","fontStyle","paddedHeight","pageData2","xAdvance","dropShadow","codePointAt","xOffset","yOffset","kerning","_drawGlyph","_applyKerning","newChars","measureCache","first","second","amount","textureResolution","_setupContext","autoGenerateMipmaps","_stroke$width","textBaseline","strokeThickness","lineWidth","lineJoin","getCanvasFillStyle","shadowOptions","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","_stroke$width2","text","fontProperties","strokeText","fillText","TextStyle","DynamicBitmapFont","getBitmapTextLayout","trimEnd","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","isEnd","charData","test","wordWrap","nextCharWidth","align","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","fontCount","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","_dynamicFont$ensureCh","fontFamilyKey","lastIndexOf","Cache","fnt","once","dynamicFont","getLayout","bitmapFont","install","_options","_ref3","_ref4","textStyle","flatChars","uninstall","cacheKey","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","bitmapTextLayout","_anchor","_x","_y","initGpuText","proxyRenderable","worldScale","proxy","HTMLTextPipe","_gpuText","runners","resolutionChange","gpuText","_autoResolution","htmlText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","error","updateQuadBounds","_htmlText$resolution","generatingTexture","getManagedTexture","gpuTextData","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyleString","toHex","fontWeight","fontVariant","whiteSpace","breakWords","strokeToCSS","dropShadowToCSS","cssOverrides","cssStyles","tagStyles","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","setAlpha","HTMLTextStyle","_this$cssOverrides","_options$tagStyles","_cssOverrides","_generateKey","generateTextStyleKey","_cssStyle","cssStyle","addOverride","toAdd","removeOverride","toRemove","loadFontCSS","url","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","tempHTMLTextRenderData","HTMLTextSystem","_activeTextures","_createCanvas","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","fontFamilies","dedupe","matches","addFontFamily","fontFamily2","extractFontFamilies","fontCSS","fontPromises","all","getFontCss","defaultTextStyle","measured","fontStyleCSS","htmlTextRenderData","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","isSafari","drawImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","defaultFontOptions","_TextStyle","oldStyle","_oldStyle$dropShadowA","_oldStyle$dropShadowA2","_oldStyle$dropShadowB","_oldStyle$dropShadowC","_oldStyle$dropShadowD","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","dropShadowColor","obj","hasOwnProperty","fillGradientStops","gradientFill","fills","convertV7Tov8Style","fullStyle","_align","_breakWords","_dropShadow","_createProxy","_fontFamily","_fontSize","_fontStyle","_fontVariant","_fontWeight","leading","_leading","_letterSpacing","_lineHeight","_trim","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_originalFill","_isFillStyle","_originalStroke","_this$_fill","_this$_originalFill","_this$_stroke","_this$_originalStroke","cb","Proxy","newValue","contextSettings","willReadFrequently","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","proto","getCanvasRenderingContext2D","prototype","lineWidths","maxLineWidth","_canvas","_measurementCache","__context","_measureText","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","metricWidth","actualBoundingBoxLeft","boundsWidth","actualBoundingBoxRight","val","graphemeSegmenter","cache","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_fonts","METRICS_STRING","BASELINE_SYMBOL","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","OffscreenCanvas","_cx","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","_Intl","Intl","Segmenter","segmenter","genericFontFamilies","fontSizeString","_fillStyle$alpha","pattern","createPattern","fillPattern","fillGradient","CanvasTextPipe","textUid","canvasText","checkRow","checkColumn","top","CanvasTextSystem","getTextureSize","_textKey","createTextureAndCanvas","_options$resolution","renderTextToCanvas","trimmed","TypeError","getImageData","left","getCanvasBoundingBox","lineCap","linePositionX","linePositionY","passesCount","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","toRgbaString","_style$_stroke2","linePositionYShift","_style$_stroke4","_drawLetterSpacing","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","valuesToIterateForKeys","prop","addFillStyleKey","addStokeStyleKey","addDropShadowKey","_fillStyle$fill","tempBounds","sizeOrBuffer","ArrayBuffer","int8View","_int8View","Int8Array","uint8View","_uint8View","int16View","_int16View","Int16Array","int32View","_int32View","float64View","_float64Array","bigUint64View","_bigUint64Array","BigUint64Array","view","uint16View","sizeOf"],"sourceRoot":""}